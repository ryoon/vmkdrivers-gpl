/* ***************************************************************************
 * Copyright 2005-2008, 2010 VMware, Inc.  All rights reserved.
 *
 * **************************************************************************/

/*
 * vmklinux_module.c --
 *
 *      This file defines the entry points for the early module init and late
 *      cleanup routines for modules that uses the services from vmklinux.
 *
 *      Currently, the early module init routine is used to create the
 *      module private heap and the late cleanup routine is used to destroy
 *      the heap. The private heap guarantees that modules and other kernel
 *      code don't step on each other's toes. This functionality is available
 *      to any module that links with this code. Options specifying the size
 *      of the private heap, among other things, must be present within the
 *      module's Makefile, providing defined preprocessing values to the
 *      compiler. Those preprocessing defines should be:
 *
 *      Optional:
 *      - VMKLINUX_MODULE_USE_EXTERNAL_HEAP
 *      - VMKLINUX_MODULE_HEAP_ANY_MEM
 *      - VMKLINUX_MODULE_HEAP_512GB_MEM
 *      - VMKLINUX_MODULE_HEAP_4GB_MEM
 *      - VMKLINUX_MODULE_HEAP_2GB_MEM
 *      - VMKLINUX_MODULE_HEAP_PHYS_ANY_CONTIGUITY
 *      - VMKLINUX_MODULE_HEAP_PHYS_CONTIGUOUS
 *      - VMKLINUX_MODULE_HEAP_PHYS_DISCONTIGUOUS
 *
 *      Required if VMKLINUX_MODULE_USE_EXTERNAL_HEAP is not defined:
 *
 *      - LINUX_MODULE_HEAP_INITIAL=<number-in-bytes-guaranteed-allocated>
 *      - LINUX_MODULE_HEAP_MAX=<number-in-bytes-of-maximum-allocation>
 *      - LINUX_MODULE_HEAP_NAME=<string>
 *
 *      These optional parameters provide the means to control exactly which
 *      type of heap is created for a given module. The default is for a heap
 *      to be 4GB_MEM and CONTIGUOUS, to match the type of memory returned to
 *      drivers in Linux.
 *
 *      However, if at all possible, drivers should be transitioned from
 *      LOW->ANY, and from CONTIGUOUS->ANY_CONTIGUITY. The remaining two options,
 *      HIGH and DISCONTIGUOUS, should be mainly used while performing driver
 *      functionality sanity checks while making these transitions.
 */

#include "vmkapi.h"
#include "vmklinux_version.h"
#include "vmklinux_dist.h"
#include "vmklinux_mempool.h"
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/list.h>
#include <linux/module.h>
#include <linux/dma-mapping.h>
#include <linux/interrupt.h>
#include <linux/skbuff.h>
#include <linux/kernel.h>
#include <scsi/scsi_device.h>

#ifndef MODULE
#error "You can only compile and link vmklinux_module with modules, which" \
       "means that MODULE has to be defined when compiling it..."
#endif

/* Modules are built using the latest vmkapi */
VMK_NAMESPACE_REQUIRED(VMK_NAMESPACE_VMKAPI,
                       VMK_NAMESPACE_CURRENT_VERSION);
#if VMKAPI_REVISION >= VMK_REVISION_FROM_NUMBERS(2, 2, 0, 0) && \
    defined(VMK_DEVKIT_USES_BINARY_INCOMPATIBLE_APIS)
VMK_NAMESPACE_REQUIRED(VMK_NAMESPACE_VMKAPI_INCOMPAT,
                       VMK_NAMESPACE_INCOMPAT_CURRENT_VERSION);
#endif

/******************************************************************************
 *                                                                            *
 *               M O D U L E   N A M E S P A C E   S E C T I O N              *
 *                                                                            *
 ******************************************************************************/
/*
 * Drivers are built using the latest vmkdriver version interface.
 */
#if !defined(VMKLINUX)
VMK_NAMESPACE_REQUIRED(VMKLINUX_NAMESPACE, VMKLNX_NS_CURRENT_VERSION);

/*
 * This driver might export or import namespaces.
 * NOTE: __namespace.h is generated by the build from the driver's .sc file.
 */
#if defined(_VMKDRVEI)
#include "__namespace.h"
#endif
#endif

/******************************************************************************
 *                                                                            *
 *           M O D U L E    H E A P / M E M P O O L    S E C T I O N          *
 *                                                                            *
 ******************************************************************************/
#define MEMPOOL_NAME_SIZE VMK_MISC_NAME_MAX

#ifndef VMKLINUX_MODULE_USE_EXTERNAL_HEAP
/*
 * By default, we use an internal module private heap,
 * unless the module compilation explicitly specified
 * to use an external heap.
 */
#define VMKLINUX_MODULE_USE_INTERNAL_HEAP
#endif

#ifdef VMKLINUX_MODULE_USE_INTERNAL_HEAP /* { */
/*
 * This is the beginning of a big #ifdef section
 */

#ifndef LINUX_MODULE_HEAP_INITIAL
#error
#endif

#ifndef LINUX_MODULE_HEAP_MAX
#error
#endif

#ifndef LINUX_MODULE_HEAP_NAME
#error
#endif

#if LINUX_MODULE_HEAP_INITIAL > LINUX_MODULE_HEAP_MAX
#error
#endif

#if LINUX_MODULE_HEAP_INITIAL < 0
#error
#endif

/* Can only define one HEAP_PHYS attribute */
#ifdef VMKLINUX_MODULE_HEAP_PHYS_ANY_CONTIGUITY
#ifdef VMKLINUX_MODULE_HEAP_PHYS_CONTIGUOUS
#error
#endif
#ifdef VMKLINUX_MODULE_HEAP_PHYS_DISCONTIGUOUS
#error
#endif

#define PHYS_TYPE (VMK_MEM_PHYS_ANY_CONTIGUITY)

#elif VMKLINUX_MODULE_HEAP_PHYS_DISCONTIGUOUS
#ifdef VMKLINUX_MODULE_HEAP_PHYS_CONTIGUOUS
#error
#endif

#define PHYS_TYPE (VMK_MEM_PHYS_DISCONTIGUOUS)

#else // Nothing defined or PHYS_CONTIGOUS

#define PHYS_TYPE (VMK_MEM_PHYS_CONTIGUOUS)

#endif

/* Can only define one HEAP MEM attribute */
#ifdef LINUX_MODULE_HEAP_DMA_WIDTH
#if defined(VMKLINUX_MODULE_HEAP_ANY_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_4GB_MEM) || \
    defined(VMKLINUX_MODULE_HEAP_512GB_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_2GB_MEM)
#error
#endif

#elif VMKLINUX_MODULE_HEAP_ANY_MEM
#if defined(VMKLINUX_MODULE_HEAP_4GB_MEM) || \
    defined(VMKLINUX_MODULE_HEAP_512GB_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_2GB_MEM) ||\
    defined(LINUX_MODULE_HEAP_DMA_WIDTH)
#error
#endif

#define LINUX_MODULE_HEAP_DMA_WIDTH             64

#elif VMKLINUX_MODULE_HEAP_512GB_MEM
#if defined(VMKLINUX_MODULE_HEAP_4GB_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_ANY_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_2GB_MEM) ||\
    defined(LINUX_MODULE_HEAP_DMA_WIDTH)
#error
#endif

#define LINUX_MODULE_HEAP_DMA_WIDTH             39

#elif VMKLINUX_MODULE_HEAP_4GB_MEM
#if defined(VMKLINUX_MODULE_HEAP_ANY_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_512GB_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_2GB_MEM) ||\
    defined(LINUX_MODULE_HEAP_DMA_WIDTH)
#error
#endif

#define LINUX_MODULE_HEAP_DMA_WIDTH             32

#elif VMKLINUX_MODULE_HEAP_2GB_MEM
#if defined(VMKLINUX_MODULE_HEAP_4GB_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_ANY_MEM) ||\
    defined(VMKLINUX_MODULE_HEAP_512GB_MEM) ||\
    defined(LINUX_MODULE_HEAP_DMA_WIDTH)
#error
#endif

#define LINUX_MODULE_HEAP_DMA_WIDTH             31

#else // Nothing defined - assume 4GB_MEM

#define LINUX_MODULE_HEAP_DMA_WIDTH             32

#endif

/*
 * XXX: VMK_MODULE_HEAP_ID and __this_module.heapID are redundant currently
 * At some later point this has to be cleaned up
 */
vmk_HeapID VMK_MODULE_HEAP_ID = VMK_INVALID_HEAP_ID;

static int heap_initial = LINUX_MODULE_HEAP_INITIAL;
module_param(heap_initial, int, 0444);
MODULE_PARM_DESC(heap_initial, "Initial heap size allocated for the driver.");

static int heap_max = LINUX_MODULE_HEAP_MAX;
module_param(heap_max, int, 0444);
MODULE_PARM_DESC(heap_max, "Maximum attainable heap size for the driver.");

/* Forward declarations */
static VMK_ReturnStatus vmklnx_module_mempool_init(void);
static VMK_ReturnStatus vmklnx_module_mempool_cleanup(void);
static VMK_ReturnStatus vmklnx_module_heap_cleanup(void);
#ifdef LINUX_MODULE_SKB_HEAP
static VMK_ReturnStatus vmklnx_module_skb_mpool_cleanup(void);
#ifndef VMKLINUX_MODULE_USE_EXTERNAL_HEAP
static VMK_ReturnStatus vmklnx_module_skb_mpool_init(void);
#endif
#endif

/*
 * The following two functions are used to create and destroy the private module
 * heap. The init function MUST be called before any other code in the module
 * has a chance to call kfree, kmalloc, etc. And the destroy function MUST be
 * called after those operations are all finished.
 *
 */
static VMK_ReturnStatus
vmklnx_module_heap_init(void)
{
   VMK_ReturnStatus status;
   vmk_ScsiSystemLimits limits;
   vmk_HeapCreateProps props;
   vmk_MA machineMaxPhysAddr = vmk_MachMemMaxAddr();
   vmk_MA driverMaxPhysAddr = DMA_BIT_MASK(LINUX_MODULE_HEAP_DMA_WIDTH);
   vmk_MemPhysAddrConstraint memType;

   vmk_ScsiGetSystemLimits(&limits);

   heap_max += limits.maxPaths * sizeof(struct scsi_device);

#if defined(VMKLINUX)
   #define MAX_CONCURRENT_THREAD_CREATION 5

   vmk_ByteCount worldCreateSize = 0, worldCreateAlignment = 0;
   vmk_ByteCount largeHeapMax = (vmk_ByteCount)heap_max;

   worldCreateSize = vmk_WorldCreateAllocSize(&worldCreateAlignment);
   vmk_HeapAllocationDescriptor heapAllocDesc[] = {
           { heap_max, 0, 1},
           { worldCreateSize, worldCreateAlignment,
             MAX_CONCURRENT_THREAD_CREATION}
   };

   status = vmk_HeapDetermineMaxSize(heapAllocDesc,
                                     ARRAY_SIZE(heapAllocDesc),
                                     &largeHeapMax);
   if (status != VMK_OK) {
           vmk_WarningMessage("vmk_HeapDetermineMaxSize failed: %s",
                              vmk_StatusToString(status));
           return status;
   }
   heap_max = (int) largeHeapMax;
#endif

   if (heap_max < LINUX_MODULE_HEAP_MAX) {
      vmk_WarningMessage("module heap %s: user specified heap_max (%d) < default (%d).",
                         VMK_MODULE_HEAP_NAME, heap_max, LINUX_MODULE_HEAP_MAX);
   }

   if (heap_initial < LINUX_MODULE_HEAP_INITIAL) {
      vmk_WarningMessage("module heap %s: user specified heap_initial (%d) < default (%d).",
                         VMK_MODULE_HEAP_NAME, heap_initial, LINUX_MODULE_HEAP_INITIAL);
   }

   if (heap_initial > heap_max) {
      vmk_WarningMessage("module heap %s: user specified heap_initial (%d) > heap_max (%d). "
                         "Limiting to max!!!",
                         VMK_MODULE_HEAP_NAME, heap_initial, heap_max);
      heap_initial = heap_max;
   }

   vmk_LogMessage("module heap %s: Initial heap size = %d, max heap size = %d",
                  VMK_MODULE_HEAP_NAME, heap_initial, heap_max);

   status = vmklnx_module_mempool_init();
   VMK_ASSERT(status == VMK_OK);
   if (status != VMK_OK) {
      return status;
   }

   /* compute heap physical address constraint */
   if (driverMaxPhysAddr >= machineMaxPhysAddr) {
      memType = VMK_PHYS_ADDR_ANY;
   } else if (driverMaxPhysAddr >= DMA_BIT_MASK(39)) {
      memType = VMK_PHYS_ADDR_BELOW_512GB;
   } else if (driverMaxPhysAddr >= DMA_BIT_MASK(32)) {
      memType = VMK_PHYS_ADDR_BELOW_4GB;
   } else if (driverMaxPhysAddr >= DMA_BIT_MASK(31)) {
      memType = VMK_PHYS_ADDR_BELOW_2GB;
   } else {
      vmk_WarningMessage("module heap %s: dma width (%d) too small, min is 31",
                         VMK_MODULE_HEAP_NAME, LINUX_MODULE_HEAP_DMA_WIDTH);
      return VMK_FAILURE;
   }
   vmk_LogMessage("module heap %s: using memType %d", VMK_MODULE_HEAP_NAME, memType);
   THIS_MODULE->primary_mem_info.mem_phys_addr_type = memType;

   status = vmk_NameInitialize(&props.name, VMK_MODULE_HEAP_NAME);
   VMK_ASSERT(status == VMK_OK);
   props.module = vmklnx_this_module_id;
   props.initial = heap_initial;
   props.max = heap_max;
   props.type = VMK_HEAP_TYPE_MEMPOOL;
   props.typeSpecific.memPool.physContiguity = PHYS_TYPE;
   props.typeSpecific.memPool.physRange = memType;
   props.typeSpecific.memPool.memPool = THIS_MODULE->primary_mem_info.mempool;
   props.creationTimeoutMS = VMK_TIMEOUT_NONBLOCKING;

   status = vmk_HeapCreate(&props, &THIS_MODULE->primary_mem_info.heapID);

   if (status != VMK_OK) {
      vmk_LogMessage("module heap %s: creation failed - %s",
                     VMK_MODULE_HEAP_NAME, vmk_StatusToString(status));
      vmklnx_module_mempool_cleanup();
      return status;
   } else {
      vmk_LogMessage("module heap %s: creation succeeded. id = %p",
                     VMK_MODULE_HEAP_NAME, THIS_MODULE->primary_mem_info.heapID);
   }

   VMK_MODULE_HEAP_ID = THIS_MODULE->primary_mem_info.heapID;

   vmk_ModuleSetHeapID(vmklnx_this_module_id, THIS_MODULE->primary_mem_info.heapID);

#ifdef LINUX_MODULE_SKB_HEAP
   {
      char cache_name[VMK_MISC_NAME_MAX];
      char module_name[VMK_MISC_NAME_MAX];

      // used only for slab creation, not for the memorying backing the slab objects
      THIS_MODULE->skb_mem_info.heapID = THIS_MODULE->primary_mem_info.heapID;

      vmk_ModuleGetName(vmklnx_this_module_id, module_name, sizeof(module_name));
      vmk_Snprintf(cache_name, sizeof(cache_name), "vmklnx_%s_skb_cache", module_name);
      THIS_MODULE->skb_cache = vmklnx_kmem_cache_create(&THIS_MODULE->skb_mem_info,
                                                        cache_name,
                                                        vmklnx_skb_real_size() +
                                                           sizeof(struct skb_shared_info),
                                                        0,
                                                        NULL,
                                                        NULL);

      if (THIS_MODULE->skb_cache == NULL) {
         vmk_WarningMessage("skb_cache creation for module %s failed.", module_name);
         vmklnx_module_heap_cleanup();
         return VMK_FAILURE;
      }
   }
#endif

   return VMK_OK;
}

static VMK_ReturnStatus
vmklnx_module_mempool_cleanup(void)
{
   VMK_ReturnStatus status = VMK_OK;

   if (THIS_MODULE->primary_mem_info.mempool != VMK_MEMPOOL_INVALID) {
      status = vmk_MemPoolDestroy(THIS_MODULE->primary_mem_info.mempool);
      THIS_MODULE->primary_mem_info.mempool = VMK_MEMPOOL_INVALID;
   }
#ifdef LINUX_MODULE_SKB_HEAP
   {
      VMK_ReturnStatus status1 = vmklnx_module_skb_mpool_cleanup();
      if (status == VMK_OK) {
         status = status1;
      }
   }
#endif
#if defined(VMKLINUX)
   if (THIS_MODULE->parent_mem_pool != VMK_MEMPOOL_INVALID) {
      VMK_ReturnStatus status2;
      status2 = vmk_MemPoolDestroy(THIS_MODULE->parent_mem_pool);
      VMK_ASSERT(status2 == VMK_OK);
   }
#endif
   return status;
}

static VMK_ReturnStatus
vmklnx_module_heap_cleanup(void)
{
   VMK_ReturnStatus status;

#ifdef LINUX_MODULE_SKB_HEAP
   if (THIS_MODULE->skb_cache) {
      vmklnx_kmem_cache_destroy(THIS_MODULE->skb_cache);
      THIS_MODULE->skb_cache = NULL;
   }
#endif

   vmk_HeapDestroy(THIS_MODULE->primary_mem_info.heapID);
   VMK_MODULE_HEAP_ID = THIS_MODULE->primary_mem_info.heapID = VMK_INVALID_HEAP_ID;
   status = vmklnx_module_mempool_cleanup();

   return status;
}


static VMK_ReturnStatus
vmklnx_module_mempool_init(void)
{
   vmk_MemPoolProps mpool_props;
   char module_name[VMK_MISC_NAME_MAX];
   VMK_ReturnStatus status;
   /*
    * For now, use the same limits provided for the module heap to create mempool.
    *
    *   We may wish to use the same mempool for the module skb_mem_info slab in the future,
    *   but for now they are separate.
    */
   int mempool_initial = heap_initial;
   int mempool_max = heap_max;

   vmk_LogMessage("%s: Mempool max %d being used for module: %d",
                  __FUNCTION__, mempool_max, THIS_MODULE->moduleID);

   vmk_ModuleGetName(THIS_MODULE->moduleID, module_name, sizeof(module_name));

#if defined(VMKLINUX)
   status = vmklnx_mem_pool_parent_init();
#else
   status = vmklnx_mem_pool_get_parent(&(THIS_MODULE->parent_mem_pool));
#endif
   VMK_ASSERT(status == VMK_OK);

   /*
    * Initialize per module mempool if module defined it
    * Slabs via vmklnx_kmem_cache_create() are backed by this per-module mempool
    */
   mpool_props.module = THIS_MODULE->moduleID;
   mpool_props.parentMemPool = THIS_MODULE->parent_mem_pool;
   mpool_props.memPoolType = VMK_MEM_POOL_LEAF;
   mpool_props.resourceProps.reservation =
      VMK_UTIL_ROUNDUP(mempool_initial, VMK_PAGE_SIZE) / VMK_PAGE_SIZE;
   mpool_props.resourceProps.limit =
      VMK_UTIL_ROUNDUP(mempool_max, VMK_PAGE_SIZE) / VMK_PAGE_SIZE;
   status = vmk_NameFormat(&mpool_props.name, "vmklnx_%s", module_name);
   VMK_ASSERT(status == VMK_OK);
   status = vmk_MemPoolCreate(&mpool_props, &THIS_MODULE->primary_mem_info.mempool);
   if (status != VMK_OK) {
      THIS_MODULE->primary_mem_info.mempool = VMK_MEMPOOL_INVALID;  /* Just to be sure */
      vmk_WarningMessage("vmk_MemPoolCreate failed  0x%x.", status);
      VMK_ASSERT(0);
      return status;
   } else {
      vmk_LogMessage("vmk_MemPoolCreate passed for %d pages",
                     mpool_props.resourceProps.reservation);
   }

#ifdef LINUX_MODULE_SKB_HEAP
   status = vmklnx_module_skb_mpool_init();

   if (status != VMK_OK) {
      vmk_MemPoolDestroy(THIS_MODULE->primary_mem_info.mempool);
      THIS_MODULE->primary_mem_info.mempool = VMK_MEMPOOL_INVALID;
   }

#endif

   return status;
}

#else /* } VMKLINUX_MODULE_USE_EXTERNAL_HEAP { */

static const char external_heap_name[] = VMK_STRINGIFY(LINUX_MODULE_HEAP_NAME);
static const char heap_prefix[] = "vmklnx_";
vmk_HeapID VMK_MODULE_HEAP_ID = VMK_INVALID_HEAP_ID;

static VMK_ReturnStatus
vmklnx_module_heap_init(void)
{
   char module_name[VMK_MISC_NAME_MAX];
   vmk_ModuleID ext_mod_id = VMK_INVALID_MODULE_ID;
   struct module *ext_mod;
   const char *external_module_name;

   if (vmk_Strncmp(external_heap_name, heap_prefix, sizeof(heap_prefix) - 1) != 0) {
      vmk_WarningMessage("%s: impropertly formulated external heap name %s",
                         __FUNCTION__, external_heap_name);
      return VMK_BAD_PARAM;
   }
   external_module_name = external_heap_name + sizeof(heap_prefix) - 1;

   ext_mod_id = vmk_ModuleGetID(external_module_name);
   if (ext_mod_id == VMK_INVALID_MODULE_ID) {
      vmk_WarningMessage("%s: Could not find module id for external module %s",
                  __FUNCTION__, external_module_name);
      return VMK_NOT_FOUND;
   }

   ext_mod = vmklnx_get_module(ext_mod_id);
   if (ext_mod == NULL) {
      vmk_WarningMessage("%s: Could not find external module %s ext_mod_id:%d",
                  __FUNCTION__, external_module_name, ext_mod_id);
      return VMK_NOT_FOUND;
   }

   THIS_MODULE->primary_mem_info = ext_mod->primary_mem_info;
   THIS_MODULE->skb_mem_info = ext_mod->skb_mem_info;
   VMK_MODULE_HEAP_ID = ext_mod->skb_mem_info.heapID;

   vmk_ModuleSetHeapID(vmklnx_this_module_id, THIS_MODULE->primary_mem_info.heapID);
   vmk_ModuleGetName(vmklnx_this_module_id, module_name, sizeof(module_name));
   vmk_LogMessage("%s uses external heap for module %s id = %p",
                  module_name, external_module_name, THIS_MODULE->primary_mem_info.heapID);
   /* Exit holding a ref count on the ext mod id */
   return VMK_OK;
}

static VMK_ReturnStatus
vmklnx_module_heap_cleanup(void)
{
   vmk_ModuleID ext_mod_id = VMK_INVALID_MODULE_ID;
   struct module *ext_mod;
   const char *external_module_name = external_heap_name + sizeof(heap_prefix) - 1;

   ext_mod_id = vmk_ModuleGetID(external_module_name);
   if (ext_mod_id == VMK_INVALID_MODULE_ID) {
      vmk_WarningMessage("%s: Could not find module id for external module %s",
                  __FUNCTION__, external_module_name);
      return VMK_NOT_FOUND;
   }

   ext_mod = vmklnx_put_module(ext_mod_id);

   return VMK_OK;
}

#endif /* } VMKLINUX_MODULE_USE_EXTERNAL_HEAP */

/******************************************************************************
 *                                                                            *
 *                     S K B   H E A P   S E C T I O N                        *
 *                                                                            *
 ******************************************************************************/
#ifdef LINUX_MODULE_SKB_HEAP /* { */

#ifndef VMKLINUX_MODULE_USE_EXTERNAL_HEAP /* { */
static int skb_mpool_initial = LINUX_MODULE_SKB_HEAP_INITIAL;
module_param(skb_mpool_initial, int, 0444);
MODULE_PARM_DESC(skb_mpool_initial, "Driver's minimum private socket buffer memory pool size.");

static int skb_mpool_max = LINUX_MODULE_SKB_HEAP_MAX;
module_param(skb_mpool_max, int, 0444);
MODULE_PARM_DESC(skb_mpool_max, "Maximum attainable private socket buffer memory pool size for the driver.");

static VMK_ReturnStatus
vmklnx_module_skb_mpool_init(void)
{
   vmk_MemPoolProps mpool_props;
   char module_name[VMK_MISC_NAME_MAX];
   VMK_ReturnStatus status;

   vmk_ModuleGetName(THIS_MODULE->moduleID, module_name, sizeof(module_name));
   status = vmk_NameFormat(&mpool_props.name, "vmklnx_%s_skb", module_name);
   VMK_ASSERT(status == VMK_OK);

   if (skb_mpool_max < LINUX_MODULE_SKB_HEAP_MAX) {
      vmk_WarningMessage("module mempool %s: user specified skb_mpool_max (%d) < default (%d).",
                         vmk_NameToString(&mpool_props.name), skb_mpool_max,
                         LINUX_MODULE_SKB_HEAP_MAX);
   }

   if (skb_mpool_initial < LINUX_MODULE_SKB_HEAP_INITIAL) {
      vmk_WarningMessage("module mempool %s: user specified skb_mpool_initial (%d) < default (%d).",
                         vmk_NameToString(&mpool_props.name), skb_mpool_initial,
                         LINUX_MODULE_SKB_HEAP_INITIAL);
   }

   if (skb_mpool_initial > skb_mpool_max) {
      vmk_WarningMessage("module mempool %s: user specified skb_mpool_initial (%d) > skb_mpool_max (%d). "
                         "Limiting to skb_mpool_max!!!",
                         vmk_NameToString(&mpool_props.name), skb_mpool_initial, skb_mpool_max);
      skb_mpool_initial = skb_mpool_max;
   }

   mpool_props.module = THIS_MODULE->moduleID;
   mpool_props.parentMemPool = THIS_MODULE->parent_mem_pool;
   mpool_props.memPoolType = VMK_MEM_POOL_LEAF;
   mpool_props.resourceProps.reservation =
      (skb_mpool_initial + (VMK_PAGE_SIZE - 1))/ VMK_PAGE_SIZE;
   mpool_props.resourceProps.limit =
      (skb_mpool_max + (VMK_PAGE_SIZE - 1))/ VMK_PAGE_SIZE;

   status = vmk_MemPoolCreate(&mpool_props, &THIS_MODULE->skb_mem_info.mempool);
   if (status != VMK_OK) {
      vmk_WarningMessage("module mempool %s: creation failed - %s.",
                         vmk_NameToString(&mpool_props.name), vmk_StatusToString(status));
      VMK_ASSERT(0);
      return status;
   }
   vmk_LogMessage("module mempool %s: creation succeeded. initial size = %d, max size = %d",
                  vmk_NameToString(&mpool_props.name), skb_mpool_initial, skb_mpool_max);

   return VMK_OK;
}

static VMK_ReturnStatus
vmklnx_module_skb_mpool_cleanup(void)
{
   VMK_ReturnStatus status = VMK_OK;

   if (THIS_MODULE->skb_mem_info.mempool != VMK_MEMPOOL_INVALID) {
      if ((status = vmk_MemPoolDestroy(THIS_MODULE->skb_mem_info.mempool)) != VMK_OK) {
         vmk_LogMessage("skb_mem_info mempool cleanup error 0x%x for module %d", status,
                        THIS_MODULE->moduleID);
      }
      THIS_MODULE->skb_mem_info.mempool = VMK_MEMPOOL_INVALID;
   }

   return status;
}
#endif /* } !VMKLINUX_MODULE_USE_EXTERNAL_HEAP */
#endif /* } LINUX_MODULE_SKB_HEAP */


/******************************************************************************
 *                                                                            *
 *               C O H E R E N T   D M A   S E C T I O N                      *
 *                     per-module DMA heap support                            *
 *                                                                            *
 ******************************************************************************/
vmk_HeapID VMK_MODULE_CODMA_HEAP_ID = VMK_INVALID_HEAP_ID;
struct vmklnx_codma vmklnx_codma;
static char *vmklnx_codma_name = VMK_MODULE_CODMA_HEAP_NAME;
static struct semaphore vmklnx_codma_mutex;


/******************************************************************************
 *                                                                            *
 *                           R C U   S E C T I O N                            *
 *                                                                            *
 ******************************************************************************/
struct vmklnx_rcu_data vmklnx_rcu_data;
struct tasklet_struct vmklnx_callback_tasklet;
struct timer_list vmklnx_rcu_timer;


/******************************************************************************
 *                                                                            *
 *                        M O D U L E   S E C T I O N                         *
 *                                                                            *
 ******************************************************************************/
vmk_ModuleID vmklnx_this_module_id;
struct module __this_module = {
   .version = VMKLNX_DDI_VERSION,
   .moduleID = VMK_INVALID_MODULE_ID,
   .primary_mem_info = {
      .heapID = VMK_INVALID_HEAP_ID,
      .mempool = VMK_MEMPOOL_INVALID,
      .mem_phys_contig_type = PHYS_TYPE,
   },
   .skb_mem_info = {
      .heapID = VMK_INVALID_HEAP_ID,
      .mempool = VMK_MEMPOOL_INVALID,
      .mem_phys_addr_type = VMK_PHYS_ADDR_ANY,
      .mem_phys_contig_type = VMK_MEM_PHYS_ANY_CONTIGUITY,
   },
   .moduleHandle = NULL
};

int
vmk_early_init_module(void)
{
   VMK_ReturnStatus status;

   /*
    * Verify that the module and VMkernel API revision are compatible
    */
   status = vmk_ModuleRegister(&THIS_MODULE->moduleID, VMKAPI_REVISION);

   if (status != VMK_OK) {
      vmk_WarningMessage("Registration failed (%#x): %s",
                         status, vmk_StatusToString(status));
      return status;
   }

   vmklnx_this_module_id = THIS_MODULE->moduleID;

   status = vmklnx_module_heap_init();
   if (status != 0) {
      return -1;
   }

   VMK_ASSERT(THIS_MODULE->primary_mem_info.heapID != VMK_INVALID_HEAP_ID);
   VMK_ASSERT(THIS_MODULE->primary_mem_info.mempool != VMK_MEMPOOL_INVALID);
#ifdef LINUX_MODULE_SKB_HEAP
   VMK_ASSERT(THIS_MODULE->skb_mem_info.mempool != VMK_MEMPOOL_INVALID);
#endif


#if !defined(VMKLINUX)
   if ((status = vmklnx_register_module(THIS_MODULE, vmklnx_this_module_id)) != VMK_OK) {
      vmk_WarningMessage("Registration at vmklinux failed (%#x): %s",
                         status, vmk_StatusToString(status));
      vmklnx_module_heap_cleanup();
      return -1;
   }
#endif /* !defined(VMKLINUX) */

   /*
    * Initialize the vmklinux coherent DMA structure using the
    * module heap (which gives us 32 bits of DMA).  If we need a
    * smaller mask later on, we can try to
    */
   vmklnx_codma.heapID = THIS_MODULE->primary_mem_info.heapID;
   vmklnx_codma.mask = DMA_32BIT_MASK;
   vmklnx_codma.heapName = vmklnx_codma_name;
   vmklnx_codma.heapSize = LINUX_MODULE_HEAP_MAX;
   vmklnx_codma.mutex = &vmklnx_codma_mutex;
   sema_init(vmklnx_codma.mutex, 1);

   /*
    * Initialize RCU
    */
   vmklnx_rcu_init(&vmklnx_rcu_data, &vmklnx_callback_tasklet, &vmklnx_rcu_timer);

   return 0;
}

int
vmk_late_cleanup_module(void)
{
   VMK_ReturnStatus status;

   /* Tear down */

   vmklnx_rcu_cleanup(&vmklnx_rcu_data);

   if (vmklnx_codma.mask != DMA_32BIT_MASK) {
      vmk_HeapDestroy(vmklnx_codma.heapID);
   }

   status = vmklnx_module_heap_cleanup();

#if !defined(VMKLINUX)
   {
      VMK_ReturnStatus status1 = vmklnx_unregister_module(THIS_MODULE);
      if (status == VMK_OK) {
         status = status1;
      }
   }
#endif /* !defined(VMKLINUX) */

   return (status == VMK_OK) ? 0 : -1;
}
